using System.Collections.Generic;
using UnityEngine;

namespace Megabonk.Multiplayer
{
    /// Client-side: read the actual player model transform and stream it.
    public class InputDriver : MonoBehaviour
    {
        private NetDriverCore _core;
        private Transform _source;
        private float _txTimer;
        private const float TX_INTERVAL = 0.05f;   // 20 Hz

        private float _rebindTimer;
        private const float REBIND_EVERY = 0.5f;
        private float _refreshTimer;
        private const float REFRESH_EVERY = 2f;

        private void Start()
        {
            _core = MultiplayerPlugin.Driver;
            ResolveSource("start");
        }

        private void Update()
        {
            if (_core == null)
                return;

            if (_source != null)
            {
                var go = _source.gameObject;
                if (!go || !go.activeInHierarchy)
                {
                    MultiplayerPlugin.LogS?.LogInfo("[InputDriver] Source became inactive; scheduling rebind.");
                    _source = null;
                    _rebindTimer = 0f;
                }
            }

            if (_source == null)
            {
                _rebindTimer -= Time.unscaledDeltaTime;
                if (_rebindTimer <= 0f)
                {
                    _rebindTimer = REBIND_EVERY;
                    ResolveSource("rebind");
                }
                return;
            }

            _refreshTimer -= Time.unscaledDeltaTime;
            if (_refreshTimer <= 0f)
            {
                _refreshTimer = REFRESH_EVERY;
                TryRefreshSource();
            }

            _txTimer += Time.unscaledDeltaTime;
            if (_txTimer >= TX_INTERVAL)
            {
                _txTimer = 0f;
                _core.SendPawnTransform(_source.position, _source.rotation);
            }
        }

        private void ResolveSource(string phase)
        {
            var resolved = PlayerModelLocator.Find(transform, $"InputDriver.{phase}", allowFallback: false);
            if (resolved != null)
            {
                _source = resolved;
                _refreshTimer = REFRESH_EVERY;
                if (phase == "rebind")
                    MultiplayerPlugin.LogS?.LogInfo($"[InputDriver] Rebound -> {PlayerModelLocator.Describe(_source)}");
                BroadcastAppearance();
                return;
            }

            _source = null;
            MultiplayerPlugin.LogS?.LogWarning($"[InputDriver] {phase}: locator returned null, will retry.");
        }

        private void TryRefreshSource()
        {
            var refreshed = PlayerModelLocator.Find(_source, "InputDriver.refresh", allowFallback: false);
            if (refreshed != null && refreshed != _source)
            {
                _source = refreshed;
                MultiplayerPlugin.LogS?.LogInfo($"[InputDriver] Refresh -> {PlayerModelLocator.Describe(_source)}");
                BroadcastAppearance();
            }
        }

        private void BroadcastAppearance()
        {
            if (_core == null || _source == null)
                return;

            var comps = _source.GetComponentsInChildren(typeof(SkinnedMeshRenderer), true);
            SkinnedMeshRenderer skinned = null;
            if (comps != null && comps.Length > 0)
                skinned = comps[0] as SkinnedMeshRenderer;

            if (skinned == null || skinned.sharedMesh == null)
                return;

            var materials = skinned.sharedMaterials;
            var names = new List<string>(materials?.Length ?? 0);
            if (materials != null)
            {
                for (int i = 0; i < materials.Length; i++)
                {
                    var mat = materials[i];
                    names.Add(mat ? mat.name : string.Empty);
                }
            }

            _core.SendAppearance(skinned.sharedMesh.name, names.ToArray());
        }
    }
}
